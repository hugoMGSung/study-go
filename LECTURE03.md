## Go언어 베이직

### Go언어 기초

#### Go의 특징
- 오버플로는 에러가 나기때문에 실행안됨
- 다른 타입까리 연산은 무조건 타입을 맞춰야 실행
- 인터페이스로 타입에 제약을 받지 않고 개발 

#### 패키지
- 이전에 우리가 사용한 패키지, fmt, math/rand, time ...
	- C:\Program Files\Go\src 에 모두 위치
- 코드 구조화 및 재사용
- 결합도를 낮추고 응집도는 높이기 위한
- 패키지 단위 독립적이고 작은 단위로 개발 -> 모든 언어가 동일
- 패키지 이름 > 디렉토리 이름
- 같은 패키지 내 소스파일은 디렉토리 명을 패키지 명으로 사용
- 네이밍 규칙 > public 대문자, private 소문자 사용
- 사용자가 만든 패키지는 모두 GOPATH에 지정됨

##### 패키지 설치
- 패키지 라이브러리 관리를 위해서 go.mod 파일이 생성되고 패키지의 의존성을 관리
- https://pkg.go.dev/ Pypi와 동일
- go get
	```shell
	# go kafka 라이브러리 설치 
	go get github.com/confluentinc/confluent-kafka-go/kafka
	go: downloading github.com/confluentinc/confluent-kafka-go v1.8.2

	# kafka 라이브러리 업그레이드 
	go get -u github.com/confluentinc/confluent-kafka-go/kafka

	# go.mod 파일의 모든 라이브러리 업그레이드
	go get -u all
	```

- Go는 go.mod 파일과 go.sum 파일을 이용하여 현재 사용하고 있는 모듈의 버전이 동일한지 확인

##### 패키지 만들기
- 터미널에서 테스트할 것!
- part4\mylib 폴더 생성
- test.go 생성

	```go
	package mylib

	// public method
	func TestPlus(i int32) bool {
		return i > 0
	}
	```
- cust "main/src/part4/mylib" 로 변경하면 
	- cust.TestPlus(10) 로 바꿔서 사용가능

#### 초기화 메서드
- 패키지 로드시...
- 메인메서드 보다 먼저 1회 실행되는 초기화 함수
- init() 은 패키지에 넣어서 확인 해보는 것이 좋다
- init()은 여러개를 사용해도 무방하다

- 공식 레퍼런스 - https://go.dev/doc/effective_go#initialization 확인

<img src="./images/img005.png" width="730">


#### 기본문법

##### 수 타입
- 정수 
- 정수의 문자화 
	- 아스키코드 - https://namu.wiki/w/%EC%95%84%EC%8A%A4%ED%82%A4%20%EC%BD%94%EB%93%9C
	- 유니코드 - https://namu.wiki/w/%ED%98%84%EB%8C%80%20%ED%95%9C%EA%B8%80%EC%9D%98%20%EB%AA%A8%EB%93%A0%20%EA%B8%80%EC%9E%90/%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C
- 실수, 지수
- 복소수(!)

- 타입별 최대값
- 오버플로는 자동 에러
- 수치연산은 쉬움

- 타입변환

##### 문자열 타입
- 프로그래밍에서 가장 시간이 많이 소요되는 공부
- 수자는 컴퓨터가, 문자/문자열은 사람을 위해!
- Go에서는  "", ``로 작성
- char 타입 미존재. byte, rune(int32)를 문자코드로 사용
- 탈출문자(타언어와 동일) : \n, \\, \', \", \a, \b, \f, \t
- https://www.browserling.com/tools/utf8-encode

- 문자열 익덱싱, 슬라이싱은 파이썬과 유사
- 백택(`) 은 여러줄에 편리해도 탭, 공백 등의 문제가 존재 "..." + 를 추천
- strings 패키지의 함수사용도 권장
	- 다른 언어와 사용법에 차이가 존재

##### 문자열 포맷스트링
- https://gobyexample.com/ 

|포맷|설명|예|
|---|---|---|
|%v|일반|{1 2}|
|%+v|필드명 추가|{x:1 y:2}|
|%#v|코드 스니펫|main.point{x:1, y:2}|
|%T|타입|main.point|
|%t|불린값|false|
|%d|10진수|135|
|%b|바이너리|10000001|
|%c|정수의 문자|97|
|%s|문자열|"Golang"|
|%q|문자열에 쌍따옴표|"\"Golang\""|
|%o|8진수|777|
|%x|16진수|FF|
|%f|실수|3.14|
|%e|실수|1.234000e+10|
|%E|실수|1.234000E+10|
|%p|포인터표현|0xc0000161a9|
|%6d|여섯자리 오른쪽정렬|    67|
|%-6d|여섯자리 왼쪽정렬|67    |
|%4.2f|실수 정밀도|3.14|

##### Boolean 타입
- 참거짓에 대한 데이터형
- if 문의 필수

##### 배열
- 컬렉션 종류 중 하나
	- 배열은 용량, 길이가 항상 같음, 길이고정
	- 값 타입
	- 복사 전달
	- 비교연사자 사용가
	- Go에서는 배열 거의 사용하지 않음
	- 초기화 하지 않으면 0으로 자동초기화
- 배열 값 복사

##### 슬라이스
- 컬렉션 중 하나
	- 슬라이스는 **가변길이**
	- 참조 타입
	- 참조값 전달
	- 비교연산자 사용불가

- 선언방법 
	1. 배열처럼 선언
	2. make(자료형, 길이, 용량(생략시 길이))

- 얕은 복사, 깊은 복사

##### 맵
- 컬렉션 
	- 해시테이블, 딕셔너리, Key-Value의 쌍으로 된 자료구조. 순서없음
	- 참조 타입
	- make() 사용 동일

##### 포인터
- C, C++에서 지원하는 포인터와 유사
- 변수의 지역성때문에 사용, 연속된 메모리 참조 등...
- 주소의 값은 직접 변경 불가
- *로 사용, nil로 초기화

- 기본적으로 함수내의 매개변수는 함수 소멸시 같이 소멸
- 원본값 변경을 위해서 포인터 사용
- 크기가 큰 배열등을 값 복사시 시스템 부하 -> 포인터 전달이 효율적(슬라이스, 맵은 필요없음)


##### 메서드 == 함수
- 여러번 수행할 부분을 하나의 묶음으로 만들어 계속 사용하는 것
- 수학의 f(x) = y에서 f() 를 뜻함
- 함수 전달
	- 값 전달
	- 참조 전달

- 최신(그래도) 프로그래밍 기법
	- 튜플로 다중값 리턴
	- 가변인자 메서드

- 함수를 변수에 전달(고급)
- 재귀함수
	- 수학을 잘하면 점화식 만들기 쉽고, 코드 간결
	- 코드 이해가 어렵고, 디버깅 어려움, 기억공간 많이 사용, 무한루프 가능성

- 익명함수 
	- 선언과 동시 즉시 실행

##### Defer
- 타언어 try~문의 finally와 유사
- 마지막에 실행
- 미뤄놨다가 마지막에 실행된다!
- 파일 리소스반환, 네트워크 닫기, DB연결 종료, Mutex잠금 해제...
- defer를 쓸 경우는 함수를 중첩으로 쓰지말 것(defer가 적용안 됨)

##### Closure
- 함수를 호출할 때 이전에 존재한 값을 계속 유지하기 위해서 사용
	- 비동기, 누적카운트 등...
	- 무분별한 전역변수 사용 방지
- 함수 밖의 변수를 캡쳐해서 접근해서 사용할 수 있는 함수
- 익명함수 사용할 경우 함수를 변수에 할당해서 사용가능
- 함수 안에 함수를 선언 및 정의 가능, 외부 함수에 선언된 변수에 접근가능
- 함수가 선언되는 순간 함수가 실행될 때 실체의 외부변수에 접근하기 위한 객체(스냅샷)

- 단점은 객체들이 메모리에 계속 남아있으므로 메모리부족, 오버플로우 등 발생가능

##### OOP - 사용자 정의 타입
- Go에서는 클래스와 상속 개념이 없다 - 구조체로 정의함
- 객체지향의 근본 - 클래스
	- 명사 / 속성 / 멤버변수
	- 동사 / 기능 / 메서드
	- 코드의 재사용성, 관리 용이, 현실세계와 유사한 프로그래밍 등

- Go는 전형적인 객체지향 특징은 없음
	- 인터페이스로 다형성
	- 구조체를 통한 클래스 형태의 코딩 가능
	- 구조체와 메서드의 연결을 통해 다른 언어의 클래스와 유사하기 코딩 가능

- 구조체에서 &는 구조체의 축약으로 보여줌(레퍼런스 타입)
- 기본자료형(int, float32, ...) 도 구조체로 생성가능

- 리시버 전달(값, 참조 형식)

##### 구조체 - 위에서 계속
- 구조체의 멤버변수의 값을 넣지 않으면 0으로 초기화

- 포인터 형식 - 포인터는 받아오기 역참조를 한번 더 하기 때문에 속도가 느림
- 인터페이스에서 메서드를 선언만 한 뒤 오버라이딩, 메서드에 포인터 리시버를 사용할 경우 반드시 &struct 형태 사용
- 함수의 매개변수로 전달 시 기본적으로 값복사, 필요시 포인터로 전달해야 함

- 중첩구조체일때는 바깥 구조체는 대문자, 내부구조체는 소문자로 진행

##### 포인터로 구조체 생성
- 초기화가 일반 객체 생성보다 어려움. 따로따로 멤버변수를 초기화 해야
- 초기화 메서드 필요

##### 인터페이스
- s30은 Pass
- 객체의 동작을 표현하고 골격을 나타냄
- 단순히 동작에 대한 방법만 표시
- 추상화 제공, 인터페이스의 메서드를 구현한 타입은 인터페이스로 사용가능
- 유연하게 사용할 수 있음
- 인터페이스 -> 전략패턴, 템플릿메서드, 팩토리메서드, 어댑터등 많은 디자인패턴에서 사용
- 클래스 간의 결합도 감소
- 인터페이스에서는 메서드를 정의만 하지 구현하는 것이 아님!!!

- Duck 타이핑 - 여기선 Dog 타이핑
	- 구조만 가지고 오리인지 개인지 알 수 있다. 덕타이핑

- 익명 인터페이스
- 빈인터페이스의 사용 - 어떤 타입이라도 매개변수로 받을 수 있음!!
	- 빈인터페이스를 함수로 전달받고 타입에 제약을 받지 않고 코딩하는 것 - Go의 특징

[다음](./LECTURE04.md)